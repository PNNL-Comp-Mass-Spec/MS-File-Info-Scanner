import glob
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
import matplotlib.colors as mpColors
import os
import sys
from pathlib import Path
import numpy as np
import pandas as pd
from pprint import pprint

# -------------------------------------------------------------------------------
# This file plots data generated by MSFileInfoScanner.exe, saving plots as PNG files
#
# Written by Joon Yong Lee and Matthew Monroe for the Department of Energy (PNNL, Richland, WA)
# Program started in 2017
#
# E-mail: matthew.monroe@pnnl.gov or proteomics@pnnl.gov
# Website: https://github.com/PNNL-Comp-Mass-Spec/ or https://panomics.pnnl.gov/ or https://www.pnnl.gov/integrative-omics
# -------------------------------------------------------------------------------

# When this script is invoked from C#, if text sent to print() has unicode characters, an error occurs
# For example, for the micron symbol, we see:
#   UnicodeEncodeError: 'charmap' codec can't encode character '\u03bc' in position 45: character maps to <undefined>

# To fix this, we can either force the stdout and stderr encoding to utf-8, like this:
#   import codecs
#   if sys.stdout.encoding != 'UTF-8':
#     sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
#   if sys.stderr.encoding != 'UTF-8':
#     sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# Or we can use the uprint function shown below

# Update the default font
plt.rcParams['font.family'] = ['Arial', 'FreeSans', 'DejaVu Sans']
                               
def process_file(dataFilePath):
    dataFile = Path(dataFilePath)
    if not dataFile.is_file():
        uprint('\nError, file not found: ' + dataFilePath)
        return

    uprint('Input: ', dataFile)
    data, plotLabels, columnOptions = read_file(dataFile)

    maxChargeToPlot = 6

    if len(columnOptions) >= 4:
        chargeOptions = columnOptions[3]
        if 'MaxChargeToPlot' in chargeOptions:
            maxChargeToPlot = int(chargeOptions['MaxChargeToPlot'])

    outputFilePath = str(dataFile.with_suffix('.png'))

    if len(data.columns) == 2:
        # 2D Plot
        uprint('Output:', outputFilePath)
        print()
        uprint('Plot "' + data.columns[0] + '" vs. "' + data.columns[1] + '"')
        uprint("  {:,}".format(len(data.index)) + ' data points')
        print()
        plot_lc_intensity(outputFilePath, data.columns, data[data.columns[0]], data[data.columns[1]], plotLabels['Title'], plotLabels['BottomRight'])
        return

    if len(data.columns) == 3:
        # 3D Plot
        uprint('Output:', outputFilePath)
        print()
        uprint('Plot "' + data.columns[0] + '" vs. "' + data.columns[1] + '" vs. "' + data.columns[2] + '"')
        uprint("  {:,}".format(len(data.index)) + ' data points')
        print()
        plot_lc_mz(outputFilePath, data.columns, data[data.columns[0]], data[data.columns[1]], data[data.columns[2]], plotLabels['Title'], plotLabels['BottomRight'], plotLabels['BottomLeft'])
        return

    if len(data.columns) == 4:
        # 3D Plot, with a custom color for each data point (indicating charge state)
        uprint('Output:', outputFilePath)
        print()
        uprint('Plot "' + data.columns[0] + '" vs. "' + data.columns[1] + '" vs. "' + data.columns[2] + '" coloring by ' + data.columns[3])
        uprint("  {:,}".format(len(data.index)) + ' data points')
        uprint("  MaxChargeToPlot: " + str(maxChargeToPlot))
        print()
        plot_lc_mz_by_charge(outputFilePath, data.columns, data[data.columns[0]], data[data.columns[1]], data[data.columns[2]], data[data.columns[3]], plotLabels['Title'], plotLabels['BottomRight'], plotLabels['BottomLeft'], maxChargeToPlot)
        return

    print('Unsupported number of columns: ' + str(len(data.columns)))
    print(data.columns)

def parse_metadata(plotOption):
    return {m.split('=')[0]:m.split('=')[1] for m in plotOption.split(';')}

def read_file(fpath):
    data = pd.read_csv(fpath, sep='\t', skiprows=2, header=0)
    with open(fpath, 'r', encoding="utf-8") as f:
        # The first line has the plot title and axis labels
        plotLabelData = f.readline().split('[')[1].split(']')[0]
        plotLabels = parse_metadata(plotLabelData)

        # The second line has column options
        # These are semicolon separated key/value pairs for each column, with options for each column separated by a tab
        # At present, the only option used is MaxChargeToPlot for the Charge column
        columnOptionData = f.readline().split('\t')
        columnOptions = [parse_metadata(colOption) for colOption in columnOptionData]

        # Uncomment to see options
        #
        # columnNumber = 0
        # 
        # for option in columnOptions:
        #     columnNumber += 1
        #     
        #     print()
        #     uprint("Column " + str(columnNumber) + " Options:")
        #     
        #     for item in option.keys():
        #         print(item + ": " + option[item])
        #         
        # print()
        
        return data, plotLabels, columnOptions

def set_title_and_labels(ax, plt, baseFontSize, title, xDataMin, xDataMax, xAxisLabel, yAxisLabel, yAxisFormatString, r_label, l_label):

    MAX_TITLE_LENGTH = 68

    if len(title) > MAX_TITLE_LENGTH:
        # Trim out the middle portion of the title
        # Find the first space
        spaceIndex = title.find(' ')
        if spaceIndex > 0:
            titleSuffix = title[spaceIndex:]
            charsToKeep = MAX_TITLE_LENGTH - len(titleSuffix)
            if charsToKeep > 0:
                titleToUse = title[0:charsToKeep] + titleSuffix
            else:
                titleToUse = title[-MAX_TITLE_LENGTH:]

        else:
            titleToUse = title[-MAX_TITLE_LENGTH:]
    else:
        titleToUse = title

    plt.title(titleToUse, fontsize=baseFontSize+1)

    # Assure that the X axis minimum is not negative
    xmin, xmax = plt.xlim()

    if xmin < 0:
        plt.xlim(xmin = 0)

    # When plotting BPI or TIC, fix the Y axis minimum at 0 and add 5% padding above the Y axis maximum
    # Otherwise, assure that the Y range isn't too small
    ymin, ymax = plt.ylim()

    if "- TIC -" in title or "- BPI -" in title:
        ymin = 0
        ymax += ymax * 0.05
    else:
        yRange = ymax - ymin
        if yRange < ymax * 0.20:
            # Range is less than 20% of the max value
            # Pad using 5% of the average of ymin and ymax
            yPadding = (ymin + ymax)/2.0 * 0.05
            ymin -= yPadding
            ymax += yPadding
        else:
            # Range is more than 20% of the max value
            # Pad using 5% of the range
            ymin -= yRange * 0.05
            ymax += yRange * 0.05

        if ymin < 0:
            ymin = 0

    # Uncomment to see y-axis range
    # uprint("ymin = {:,}".format(ymin))
    # uprint("ymax = {:,}".format(ymax))
        
    plt.ylim(ymin = ymin, ymax = ymax)

    # Set the X axis maximum to the max X value (in other words, we don't want any padding)
    # However, if there is only one X data point, do add some padding
    if xDataMin == xDataMax:
        plt.xlim(xmin = xDataMax - 1)
        plt.xlim(xmax = xDataMax + 1)
    else:
        plt.xlim(xmax = xDataMax)

    plt.xlabel(xAxisLabel, fontsize=baseFontSize)
    plt.ylabel(yAxisLabel, fontsize=baseFontSize)

    plt.xticks(fontsize=baseFontSize-2)
    plt.yticks(fontsize=baseFontSize-2)
    ax.yaxis.set_major_formatter(mtick.FormatStrFormatter(yAxisFormatString))
    ax.yaxis.set_minor_locator(mtick.AutoMinorLocator())

    # If the x axis range is 5 or less, assure that the minimum distance between major tick marks is at least 1
    if xDataMax - xDataMin <= 5:
        ax.xaxis.set_major_locator(mtick.MultipleLocator(1))

    ax.xaxis.set_major_formatter(mtick.FuncFormatter(lambda x, p: format(int(x), ',')))
    ax.xaxis.set_minor_locator(mtick.AutoMinorLocator())

    plt.gcf().text(0.88, 0.02, r_label, fontsize=baseFontSize-1)

    if len(l_label) > 0:
        plt.gcf().text(0.01, 0.02, l_label, fontsize=baseFontSize-1)

def plot_lc_intensity(outputFilePath, columnNames, lc_scan_num, intensities, title, r_label):

    fig = plt.figure(figsize=(8.5333,5), dpi=120)
    ax = fig.add_subplot(111, facecolor='whitesmoke')

    baseFontSize = 12

    if len(intensities) == 1:
        print ('Single point plot')
        ax.plot(lc_scan_num, intensities, linewidth=0.5, markersize=4, marker='o', color='darkblue')
    else:
        ax.plot(lc_scan_num, intensities, linewidth=0.5, color='black')

    # X axis is typically scan number
    xAxisLabel = columnNames[0]

    # Y axis is intensity
    yAxisLabel = columnNames[1]

    set_title_and_labels(ax, plt, baseFontSize, title, np.min(lc_scan_num), np.max(lc_scan_num), xAxisLabel, yAxisLabel, '%.2e', r_label, '')
    plt.tight_layout()

    plt.savefig(outputFilePath)

    print('XY plot created')

    # Uncomment to view the plot with an interactive GUI
    #plt.show()

def generate_heat_map(columnNames, xData, yData, zData, title, r_label, l_label, chargeData, maxChargeToPlot):
    fig = plt.figure(figsize=(8.5333,5.8333), dpi=120)
    ax = fig.add_subplot(111, facecolor='whitesmoke')

    baseFontSize = 12

    dataMin=np.min(zData)
    dataMedian=np.median(zData)
    dataMax=np.max(zData)
    dataRange = dataMax - dataMin

    if chargeData:
        cm = plt.cm.get_cmap('Set1')
        normMin=dataMin
        normMax=dataMax
    else:
        cm = plt.cm.get_cmap('Blues')
        normMin=dataMin-dataRange/1000
        normMax=dataMax/100

    if normMax <= normMin:
        normMax = normMin + 1

    # Uncomment to debug
    # print('Min:     ' + "{:10.2f}".format(dataMin))
    # print('Median:  ' + "{:10.2f}".format(dataMedian))
    # print('Max:     ' + "{:10.2f}".format(dataMax))
    # print('Range:   ' + "{:10.2f}".format(dataRange))
    # print('NormMin: ' + "{:10.2f}".format(normMin))
    # print('NormMax: ' + "{:10.2f}".format(normMax))

    if chargeData:
        # Define colors for charges
        # matplotlib color chart: https://stackoverflow.com/a/37232760
        
        colors = ['blue','red','green','hotpink','peru','darkviolet']
        colorForAdditionalCharges = 'indigo'
        
        dataCountOnPlot = 0
        maxChargeWithData = 1
        
        # Plot charges 1+ through maxChargeToPlot
        for chargeIndex in range(maxChargeToPlot):
            charge = chargeIndex + 1

            indicesToUse = (zData == charge)
            seriesName = "Charge " + str(charge)

            # Change the alpha value based on the number of points to point
            pointsToPlot = len(xData[indicesToUse])

            # print ('Charge {0} has {1} points'.format(charge, pointsToPlot))

            if pointsToPlot < 1:
                continue

            dataCountOnPlot += pointsToPlot
            maxChargeWithData = charge

            if pointsToPlot < 10:
                alpha = 1
            else:
                minAlpha = .2
                alpha = minAlpha + 1 - np.log10(pointsToPlot) / 5.0
                if alpha < minAlpha:
                    alpha = minAlpha
                elif alpha > 1:
                    alpha = 1

            # print("{:10,d}".format(pointsToPlot) + " points, alpha " + format(alpha, ".2f"))

            if chargeIndex < 6:
                color = colors[chargeIndex]
            else:
                color = colorForAdditionalCharges
                
            sc = ax.scatter(xData[indicesToUse], yData[indicesToUse], s=1, color=color, alpha=alpha, label=seriesName)

        if dataCountOnPlot < len(zData):
            # Not all of the data was plotted because maxChargeToPlot is lower than some of the zData values
            # Update l_label with the actual number of data points plotted
            # For example: 42,354 / 51,839 points plotted            
            l_label = "  {:,} / {:,} points plotted".format(dataCountOnPlot, len(zData))
        
        # Option 1: Create a legend using the actual symbols and sizes used by the data points
        #           This doesn't work with the small data point sizes that we're using
        # ax.legend()

        # Option 2: Add custom colored text using plt.figtext

        legendStartX = 0.943
        legendStartY = 0.85
        plt.figtext(legendStartX, legendStartY, "Charge", color='black', fontsize=baseFontSize-2)

        legendItems = []
        colorRow = 0

        for plotColor in colors:
            colorRow += 1

            if colorRow > maxChargeWithData:
                # print ("Legend will not include charge " + str(colorRow) + "+ or higher")
                break

            legendLabel = str(colorRow) + "+"
            legendPatch = mpatches.Patch(color=plotColor, label=legendLabel)
            legendItems.append(legendPatch)

            # Option 2
            plt.figtext(legendStartX + 0.016, legendStartY - colorRow/20.0, legendLabel, color=plotColor, fontsize=baseFontSize+2)

        if maxChargeWithData > 6:
            colorRow += 1
            legendLabel = ">6"
            legendPatch = mpatches.Patch(color=colorForAdditionalCharges, label=legendLabel)
            plt.figtext(legendStartX + 0.016, legendStartY - colorRow/20.0, legendLabel, color=colorForAdditionalCharges, fontsize=baseFontSize+2)
            
        # Option 3: Create a legend with custom patches
        # plt.legend(handles=legendItems, shadow = True, bbox_to_anchor=[0.99, 0.85], loc='center right', facecolor='white')

        # Uncomment to inspect the contents of variables
        # pprint(vars(fig))

        # for textItem in fig.texts:
        #    pprint(vars(textItem))

    else:
        sc = ax.scatter(xData, yData, c=zData, vmin=normMin, vmax=normMax, s=1, cmap=cm, alpha=1)

    if not chargeData:
        # Optionally show a color scale intensity legend
        # plt.colorbar(sc)
        pass

    # X axis is typically scan number
    xAxisLabel = columnNames[0]

    # Y axis is typically m/z, but could be monoisotopic mass
    yAxisLabel = columnNames[1]

    set_title_and_labels(ax, plt, baseFontSize, title, np.min(xData), np.max(xData), xAxisLabel, yAxisLabel, '%.0f', r_label, l_label)

    if chargeData:
        plt.tight_layout(rect=(0,0,0.96,1))
    else:
        plt.tight_layout()

    return plt

def plot_lc_mz(outputFilePath, columnNames, lc_scan_num, mz, intensities, title, r_label, l_label):
    plt = generate_heat_map(columnNames, lc_scan_num, mz, intensities, title, r_label, l_label, False, 6)
    plt.savefig(outputFilePath)
    print('3D plot created')

def plot_lc_mz_by_charge(outputFilePath, columnNames, lc_scan_num, mz, intensities, charge, title, r_label, l_label, maxChargeToPlot):
    plt = generate_heat_map(columnNames, lc_scan_num, mz, charge, title, r_label, l_label, True, maxChargeToPlot)

    plt.savefig(outputFilePath)
    print('3D plot (colored by charge) created')

def uprint(*objects, sep=' ', end='\n', file=sys.stdout):
    enc = file.encoding
    
    if enc.lower() == 'utf-8':
        print(*objects, sep=sep, end=end, file=file)
    else:
        f = lambda obj: str(obj).encode(enc, errors='backslashreplace').decode(enc)
        print(*map(f, objects), sep=sep, end=end, file=file)


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print('\nError: please enter the file name to process (wildcards are supported)')
        exit()

    fileNameMatchSpec = sys.argv[1]

    filesProcessed = 0
    for dataFile in glob.glob(fileNameMatchSpec):
        process_file(dataFile)
        filesProcessed += 1

    if filesProcessed == 0:
        print('\nError: no files match:\n' + fileNameMatchSpec)


# Can list fonts with the following
#import matplotlib.font_manager
#from matplotlib.font_manager import findfont, FontProperties
#fonts = matplotlib.font_manager.findSystemFonts(fontpaths=None, fontext='ttf')
#for font in sorted(fonts):
    #print(font)

# View details on a specific font with
#font = findfont(FontProperties(family=['arial']))
#print (font)
#exit()
