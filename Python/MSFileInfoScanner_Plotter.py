import glob
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
import matplotlib.colors as mpColors
import os
from pathlib import Path
import numpy as np
import pandas as pd
from pprint import pprint

# -------------------------------------------------------------------------------
# This file plots data generated by MSFileInfoScanner.exe, saving plots as PNG files
#
# Written by Joon Yong Lee and Matthew Monroe for the Department of Energy (PNNL, Richland, WA)
# Program started in 2017
#
# E-mail: matthew.monroe@pnnl.gov or proteomics@pnnl.gov
# Website: http:#omics.pnl.gov/ or http:#www.sysbio.org/resources/staff/ or http:#panomics.pnnl.gov/
# -------------------------------------------------------------------------------

# Update the default font
plt.rcParams['font.family'] = ['Arial', 'FreeSans', 'DejaVu Sans']
                               
def process_file(dataFilePath):
    dataFile = Path(dataFilePath)
    if not dataFile.is_file():
        print('\nError, file not found: ' + dataFilePath)
        return

    print('Input: ', dataFile)
    data, plotLabels, columnOptions = read_file(dataFile)

    outputFilePath = str(dataFile.with_suffix('.png'))

    if len(data.columns) == 2:
        # 2D Plot
        print('Output:', outputFilePath)
        print()
        print('Plot "' + data.columns[0] + '" vs. "' + data.columns[1] + '"')
        print("  {:,}".format(len(data.index)) + ' data points')
        print()
        plot_lc_intensity(outputFilePath, data.columns, data[data.columns[0]], data[data.columns[1]], plotLabels['Title'], plotLabels['BottomRight'])
        return

    if len(data.columns) == 3:
        # 3D Plot
        print('Output:', outputFilePath)
        print()
        print('Plot "' + data.columns[0] + '" vs. "' + data.columns[1] + '" vs. "' + data.columns[2] + '"')
        print("  {:,}".format(len(data.index)) + ' data points')
        print()
        plot_lc_mz(outputFilePath, data.columns, data[data.columns[0]], data[data.columns[1]], data[data.columns[2]], plotLabels['Title'], plotLabels['BottomRight'], plotLabels['BottomLeft'])
        return

    if len(data.columns) == 4:
        # 3D Plot, with a custom color for each data point
        print('Output:', outputFilePath)
        print()
        print('Plot "' + data.columns[0] + '" vs. "' + data.columns[1] + '" vs. "' + data.columns[2] + '" coloring by ' + data.columns[3])
        print("  {:,}".format(len(data.index)) + ' data points')
        print()
        plot_lc_mz_by_charge(outputFilePath, data.columns, data[data.columns[0]], data[data.columns[1]], data[data.columns[2]], data[data.columns[3]], plotLabels['Title'], plotLabels['BottomRight'], plotLabels['BottomLeft'])
        return

    print('Unsupported number of columns: ' + str(len(data.columns)))
    print(data.columns)

def parse_metadata(plotOption):
    return {m.split('=')[0]:m.split('=')[1] for m in plotOption.split(';')}

def read_file(fpath):
    data = pd.read_csv(fpath, sep='\t', skiprows=2, header=0)
    with open(fpath, 'r') as f:
        # The first line has the plot title and axis labels
        plotLabelData = f.readline().split('[')[1].split(']')[0]
        plotLabels = parse_metadata(plotLabelData)

        # The second line has column options
        # These are semicolon separated key/value pairs for each column, with options for each column separated by a tab
        # At present, the code does not use these column options
        columnOptionData = f.readline().split('\t')
        columnOptions = [parse_metadata(colOption) for colOption in columnOptionData]

        return data, plotLabels, columnOptions

def set_title_and_labels(ax, plt, baseFontSize, title, xDataMin, xDataMax, xAxisLabel, yAxisLabel, yAxisFormatString, r_label, l_label):

    MAX_TITLE_LENGTH = 68

    if len(title) > MAX_TITLE_LENGTH:
        # Trim out the middle portion of the title
        # Find the first space
        spaceIndex = title.find(' ')
        if spaceIndex > 0:
            titleSuffix = title[spaceIndex:]
            charsToKeep = MAX_TITLE_LENGTH - len(titleSuffix)
            if charsToKeep > 0:
                titleToUse = title[0:charsToKeep] + titleSuffix
            else:
                titleToUse = title[-MAX_TITLE_LENGTH:]

        else:
            titleToUse = title[-MAX_TITLE_LENGTH:]
    else:
        titleToUse = title

    plt.title(titleToUse, fontsize=baseFontSize+1)

    # Assure that the X axis minimum is not negative
    xmin, xmax = plt.xlim()

    if xmin < 0:
        plt.xlim(xmin = 0)

    # When plotting BPI or TIC, fix the Y axis minimum at 0 and add 5% padding above the Y axis maximum
    # Otherwise, assure that the Y range isn't too small
    ymin, ymax = plt.ylim()

    if "- TIC -" in title or "- BPI -" in title:
        ymin = 0
        ymax += ymax * 0.05
    else:
        yRange = ymax - ymin
        if yRange < ymax * 0.20:
            # Range is less than 20% of the max value
            # Pad using 5% of the average of ymin and ymax
            yPadding = (ymin + ymax)/2.0 * 0.05
            ymin -= yPadding
            ymax += yPadding
        else:
            # Range is more than 20% of the max value
            # Pad using 5% of the range
            ymin -= yRange * 0.05
            ymax += yRange * 0.05

        if ymin < 0:
            ymin = 0

    plt.ylim(ymin = ymin, ymax = ymax)

    # Set the X axis maximum to the max X value (in other words, we don't want any padding)
    # However, if there is only one X data point, do add some padding
    if xDataMin == xDataMax:
        plt.xlim(xmin = xDataMax - 1)
        plt.xlim(xmax = xDataMax + 1)
    else:
        plt.xlim(xmax = xDataMax)

    plt.xlabel(xAxisLabel, fontsize=baseFontSize)
    plt.ylabel(yAxisLabel, fontsize=baseFontSize)

    plt.xticks(fontsize=baseFontSize-2)
    plt.yticks(fontsize=baseFontSize-2)
    ax.yaxis.set_major_formatter(mtick.FormatStrFormatter(yAxisFormatString))
    ax.yaxis.set_minor_locator(mtick.AutoMinorLocator())

    # If the x axis range is 5 or less, assure that the minimum distance between major tick marks is at least 1
    if xDataMax - xDataMin <= 5:
        ax.xaxis.set_major_locator(mtick.MultipleLocator(1))

    ax.xaxis.set_major_formatter(mtick.FuncFormatter(lambda x, p: format(int(x), ',')))
    ax.xaxis.set_minor_locator(mtick.AutoMinorLocator())

    plt.gcf().text(0.88, 0.02, r_label, fontsize=baseFontSize-1)

    if len(l_label) > 0:
        plt.gcf().text(0.01, 0.02, l_label, fontsize=baseFontSize-1)

def plot_lc_intensity(outputFilePath, columnNames, lc_scan_num, intensities, title, r_label):

    fig = plt.figure(figsize=(8.5333,5), dpi=120)
    ax = fig.add_subplot(111, facecolor='whitesmoke')

    baseFontSize = 12

    if len(intensities) == 1:
        print ('Single point plot')
        ax.plot(lc_scan_num, intensities, linewidth=0.5, markersize=4, marker='o', color='darkblue')
    else:
        ax.plot(lc_scan_num, intensities, linewidth=0.5, color='black')

    # X axis is typically scan number
    xAxisLabel = columnNames[0]

    # Y axis is intensity
    yAxisLabel = columnNames[1]

    set_title_and_labels(ax, plt, baseFontSize, title, np.min(lc_scan_num), np.max(lc_scan_num), xAxisLabel, yAxisLabel, '%.2e', r_label, '')
    plt.tight_layout()

    plt.savefig(outputFilePath)

    print('XY plot created')

    # Uncomment to view the plot with an interactive GUI
    #plt.show()

def generate_heat_map(columnNames, xData, yData, zData, title, r_label, l_label, chargeData):
    fig = plt.figure(figsize=(8.5333,5.8333), dpi=120)
    ax = fig.add_subplot(111, facecolor='whitesmoke')

    baseFontSize = 12

    dataMin=np.min(zData)
    dataMedian=np.median(zData)
    dataMax=np.max(zData)
    dataRange = dataMax - dataMin

    if chargeData:
        cm = plt.cm.get_cmap('Set1')
        normMin=dataMin
        normMax=dataMax
    else:
        cm = plt.cm.get_cmap('Blues')
        normMin=dataMin-dataRange/1000
        normMax=dataMax/100

    if normMax <= normMin:
        normMax = normMin + 1

    # Uncomment to debug
    # print('Min:     ' + "{:10.2f}".format(dataMin))
    # print('Median:  ' + "{:10.2f}".format(dataMedian))
    # print('Max:     ' + "{:10.2f}".format(dataMax))
    # print('Range:   ' + "{:10.2f}".format(dataRange))
    # print('NormMin: ' + "{:10.2f}".format(normMin))
    # print('NormMax: ' + "{:10.2f}".format(normMax))

    if chargeData:
        # matplotlib color chart: https://stackoverflow.com/a/37232760

        colors = ['blue','red','green','hotpink','peru','darkviolet']

        maxChargeWithData = 1

        for chargeIndex in range(6):
            charge = chargeIndex + 1

            indicesToUse = (zData == charge)
            seriesName = "Charge " + str(charge)

            # Change the alpha value based on the number of points to point
            pointsToPlot = len(xData[indicesToUse])

            # print ('Charge {0} has {1} points'.format(charge, pointsToPlot))

            if pointsToPlot < 1:
                continue

            maxChargeWithData = charge

            if pointsToPlot < 10:
                alpha = 1
            else:
                minAlpha = .2
                alpha = minAlpha + 1 - np.log10(pointsToPlot) / 5.0
                if alpha < minAlpha:
                    alpha = minAlpha
                elif alpha > 1:
                    alpha = 1

            # print("{:10,d}".format(pointsToPlot) + " points, alpha " + format(alpha, ".2f"))

            sc = ax.scatter(xData[indicesToUse], yData[indicesToUse], s=1, color=colors[chargeIndex], alpha=alpha, label=seriesName)

        # Option 1: Create a legend using the actual symbols and sizes used by the data points
        #           This doesn't work with the small data point sizes that we're using
        # ax.legend()

        # Option 2: Add custom colored text using plt.figtext

        legendStartX = 0.943
        legendStartY = 0.85
        plt.figtext(legendStartX, legendStartY, "Charge", color='black', fontsize=baseFontSize-2)

        legendItems = []
        colorRow = 0

        for plotColor in colors:
            colorRow += 1

            if colorRow > maxChargeWithData:
                # print ("Legend will not include charge " + str(colorRow) + "+ or higher")
                break

            legendLabel = str(colorRow) + "+"
            legendPatch = mpatches.Patch(color=plotColor, label=legendLabel)
            legendItems.append(legendPatch)

            # Option 2
            plt.figtext(legendStartX + 0.016, legendStartY - colorRow/20.0, legendLabel, color=plotColor, fontsize=baseFontSize+2)

        # Option 3: Create a legend with custom patches
        # plt.legend(handles=legendItems, shadow = True, bbox_to_anchor=[0.99, 0.85], loc='center right', facecolor='white')

        # Uncomment to inspect the contents of variables
        # pprint(vars(fig))

        # for textItem in fig.texts:
        #    pprint(vars(textItem))

    else:
        sc = ax.scatter(xData, yData, c=zData, vmin=normMin, vmax=normMax, s=1, cmap=cm, alpha=1)

    if not chargeData:
        # Optionally show a color scale intensity legend
        # plt.colorbar(sc)
        pass

    # X axis is typically scan number
    xAxisLabel = columnNames[0]

    # Y axis is typically m/z, but could be monoisotopic mass
    yAxisLabel = columnNames[1]

    set_title_and_labels(ax, plt, baseFontSize, title, np.min(xData), np.max(xData), xAxisLabel, yAxisLabel, '%.0f', r_label, l_label)

    if chargeData:
        plt.tight_layout(rect=(0,0,0.96,1))
    else:
        plt.tight_layout()

    return plt

def plot_lc_mz(outputFilePath, columnNames, lc_scan_num, mz, intensities, title, r_label, l_label):
    plt = generate_heat_map(columnNames, lc_scan_num, mz, intensities, title, r_label, l_label, False)
    plt.savefig(outputFilePath)
    print('3D plot created')

def plot_lc_mz_by_charge(outputFilePath, columnNames, lc_scan_num, mz, intensities, charge, title, r_label, l_label):
    plt = generate_heat_map(columnNames, lc_scan_num, mz, charge, title, r_label, l_label, True)

    plt.savefig(outputFilePath)
    print('3D plot (colored by charge) created')

import sys

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print('\nError: please enter the file name to process (wildcards are supported)')
        exit()

    fileNameMatchSpec = sys.argv[1]

    filesProcessed = 0
    for dataFile in glob.glob(fileNameMatchSpec):
        process_file(dataFile)
        filesProcessed += 1

    if filesProcessed == 0:
        print('\nError: no files match:\n' + fileNameMatchSpec)


# Can list fonts with the following
#import matplotlib.font_manager
#from matplotlib.font_manager import findfont, FontProperties
#fonts = matplotlib.font_manager.findSystemFonts(fontpaths=None, fontext='ttf')
#for font in sorted(fonts):
    #print(font)

# View details on a specific font with
#font = findfont(FontProperties(family=['arial']))
#print (font)
#exit()
